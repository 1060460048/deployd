// Knockout Mapping plugin v2.1.0
// (c) 2011 Steven Sanderson, Roy Jacobs - http://knockoutjs.com/
// License: MIT (http://www.opensource.org/licenses/mit-license.php)
(function(a){"function"==typeof require&&"object"==typeof exports&&"object"==typeof module?a(require("knockout"),exports):"function"==typeof define&&define.amd?define(["knockout","exports"],a):a(ko,ko.mapping={})})(function(a,b){function c(a,b){for(var d in b)b.hasOwnProperty(d)&&b[d]&&(!d||!a[d]||a[d]instanceof Array?a[d]=b[d]:c(a[d],b[d]))}function d(a,b){var d={};return c(d,a),c(d,b),d}function e(a,b){a=a||{};if(a.create instanceof Function||a.update instanceof Function||a.key instanceof Function||a.arrayChanged instanceof Function)a={"":a};return b&&(a.ignore=f(b.ignore,a.ignore),a.include=f(b.include,a.include),a.copy=f(b.copy,a.copy)),a.ignore=f(a.ignore,v.ignore),a.include=f(a.include,v.include),a.copy=f(a.copy,v.copy),a.mappedProperties=a.mappedProperties||{},a}function f(a,c){return a instanceof Array||(a="undefined"===b.getType(a)?[]:[a]),c instanceof Array||(c="undefined"===b.getType(c)?[]:[c]),a.concat(c)}function g(b,c){var d=a.dependentObservable;a.dependentObservable=function(c,d,e){var e=e||{},f=e.deferEvaluation;c&&"object"==typeof c&&(e=c);var g=!1,h=function(c){var d=q({read:function(){return g||(a.utils.arrayRemoveItem(b,c),g=!0),c.apply(c,arguments)},write:function(a){return c(a)},deferEvaluation:!0});return d.__ko_proto__=q,d};return e.deferEvaluation=!0,c=new q(c,d,e),c.__ko_proto__=q,f||(b.push(c),c=h(c)),c},a.computed=a.dependentObservable;var e=c();return a.dependentObservable=d,a.computed=a.dependentObservable,e}function h(c,e,f,j,o,q){var r=a.utils.unwrapObservable(e)instanceof Array,q=q||"";if(b.isMapped(c))var u=a.utils.unwrapObservable(c)[p],f=d(u,f);var v=function(){return f[j]&&f[j].create instanceof Function},x=function(a){return g(s,function(){return f[j].create({data:a||e,parent:o})})},y=function(){return f[j]&&f[j].update instanceof Function},C=function(b,c){var d={data:c||e,parent:o,target:a.utils.unwrapObservable(b)};return a.isWriteableObservable(b)&&(d.observable=b),f[j].update(d)};if(u=t.get(e))return u;j=j||"";if(r){var r=[],E=!1,H=function(a){return a};f[j]&&f[j].key&&(H=f[j].key,E=!0),a.isObservable(c)||(c=a.observableArray([]),c.mappedRemove=function(a){var b="function"==typeof a?a:function(b){return b===H(a)};return c.remove(function(a){return b(H(a))})},c.mappedRemoveAll=function(b){var d=l(b,H);return c.remove(function(b){return-1!=a.utils.arrayIndexOf(d,H(b))})},c.mappedDestroy=function(a){var b="function"==typeof a?a:function(b){return b===H(a)};return c.destroy(function(a){return b(H(a))})},c.mappedDestroyAll=function(b){var d=l(b,H);return c.destroy(function(b){return-1!=a.utils.arrayIndexOf(d,H(b))})},c.mappedIndexOf=function(b){var d=l(c(),H),b=H(b);return a.utils.arrayIndexOf(d,b)},c.mappedCreate=function(b){if(-1!==c.mappedIndexOf(b))throw Error("There already is an object with the key that you specified.");var d=v()?x(b):b;return y()&&(b=C(d,b),a.isWriteableObservable(d)?d(b):d=b),c.push(d),d});var u=l(a.utils.unwrapObservable(c),H).sort(),K=l(e,H);E&&K.sort();for(var E=a.utils.compareArrays(u,K),u={},K=[],L=0,N=E.length;L<N;L++){var O=E[L],P,Q=q+"["+L+"]";switch(O.status){case"added":var R=k(a.utils.unwrapObservable(e),O.value,H);P=h(void 0,R,f,j,c,Q),v()||(P=a.utils.unwrapObservable(P)),Q=i(a.utils.unwrapObservable(e),R,u),K[Q]=P,u[Q]=!0;break;case"retained":R=k(a.utils.unwrapObservable(e),O.value,H),P=k(c,O.value,H),h(P,R,f,j,c,Q),Q=i(a.utils.unwrapObservable(e),R,u),K[Q]=P,u[Q]=!0;break;case"deleted":P=k(c,O.value,H)}r.push({event:O.status,item:P})}c(K),f[j]&&f[j].arrayChanged&&a.utils.arrayForEach(r,function(a){f[j].arrayChanged(a.event,a.item)})}else if(n(e)){c=a.utils.unwrapObservable(c);if(!c){if(v())return E=x(),y()&&(E=C(E)),E;if(y())return C(E);c={}}y()&&(c=C(c)),t.save(e,c),m(e,function(b){var d=q.length?q+"."+b:b;if(-1==a.utils.arrayIndexOf(f.ignore,d))if(-1!=a.utils.arrayIndexOf(f.copy,d))c[b]=e[b];else{var g=t.get(e[b])||h(c[b],e[b],f,b,c,d);a.isWriteableObservable(c[b])?c[b](a.utils.unwrapObservable(g)):c[b]=g,f.mappedProperties[d]=!0}})}else switch(b.getType(e)){case"function":y()?a.isWriteableObservable(e)?(e(C(e)),c=e):c=C(e):c=e;break;default:a.isWriteableObservable(c)?y()?c(C(c)):c(a.utils.unwrapObservable(e)):(c=v()?x():a.observable(a.utils.unwrapObservable(e)),y()&&c(C(c)))}return c}function i(a,b,c){for(var d=0,e=a.length;d<e;d++)if(!0!==c[d]&&a[d]===b)return d;return null}function j(c,d){var e;return d&&(e=d(c)),"undefined"===b.getType(e)&&(e=c),a.utils.unwrapObservable(e)}function k(b,c,d){b=a.utils.arrayFilter(a.utils.unwrapObservable(b),function(a){return j(a,d)===c});if(0==b.length)throw Error("When calling ko.update*, the key '"+c+"' was not found!");if(1<b.length&&n(b[0]))throw Error("When calling ko.update*, the key '"+c+"' was not unique!");return b[0]}function l(b,c){return a.utils.arrayMap(a.utils.unwrapObservable(b),function(a){return c?j(a,c):a})}function m(a,b){if(a instanceof Array)for(var c=0;c<a.length;c++)b(c);else for(c in a)b(c)}function n(a){var c=b.getType(a);return"object"===c&&null!==a&&"undefined"!==c}function o(){var b=[],c=[];this.save=function(d,e){var f=a.utils.arrayIndexOf(b,d);0<=f?c[f]=e:(b.push(d),c.push(e))},this.get=function(d){return d=a.utils.arrayIndexOf(b,d),0<=d?c[d]:void 0}}var p="__ko_mapping__",q=a.dependentObservable,r=0,s,t,u={include:["_destroy"],ignore:[],copy:[]},v=u;b.isMapped=function(b){return(b=a.utils.unwrapObservable(b))&&b[p]},b.fromJS=function(b){if(0==arguments.length)throw Error("When calling ko.fromJS, pass the object you want to convert.");window.setTimeout(function(){r=0},0),r++||(s=[],t=new o);var c,f;2==arguments.length&&(arguments[1][p]?f=arguments[1]:c=arguments[1]),3==arguments.length&&(c=arguments[1],f=arguments[2]),f&&(c=d(c,f[p])),c=e(c);var g=h(f,b,c);return f&&(g=f),--r||window.setTimeout(function(){a.utils.arrayForEach(s,function(a){a&&a()})},0),g[p]=d(g[p],c),g},b.fromJSON=function(c){var d=a.utils.parseJson(c);return arguments[0]=d,b.fromJS.apply(this,arguments)},b.updateFromJS=function(){throw Error("ko.mapping.updateFromJS, use ko.mapping.fromJS instead. Please note that the order of parameters is different!")},b.updateFromJSON=function(){throw Error("ko.mapping.updateFromJSON, use ko.mapping.fromJSON instead. Please note that the order of parameters is different!")},b.toJS=function(c,d){v||b.resetDefaultOptions();if(0==arguments.length)throw Error("When calling ko.mapping.toJS, pass the object you want to convert.");if(v.ignore instanceof Array){if(v.include instanceof Array){if(v.copy instanceof Array)return d=e(d,c[p]),b.visitModel(c,function(b){return a.utils.unwrapObservable(b)},d);throw Error("ko.mapping.defaultOptions().copy should be an array.")}throw Error("ko.mapping.defaultOptions().include should be an array.")}throw Error("ko.mapping.defaultOptions().ignore should be an array.")},b.toJSON=function(c,d){var e=b.toJS(c,d);return a.utils.stringifyJson(e)},b.defaultOptions=function(){if(!(0<arguments.length))return v;v=arguments[0]},b.resetDefaultOptions=function(){v={include:u.include.slice(0),ignore:u.ignore.slice(0),copy:u.copy.slice(0)}},b.getType=function(a){return a&&"object"==typeof a&&a.constructor==(new Date).constructor?"date":typeof a},b.visitModel=function(c,d,f){f=f||{},f.visitedObjects=f.visitedObjects||new o,f.parentName||(f=e(f));var g,h=a.utils.unwrapObservable(c);if(!n(h))return d(c,f.parentName);d(c,f.parentName),g=h instanceof Array?[]:{},f.visitedObjects.save(c,g);var i=f.parentName;return m(h,function(c){if(!f.ignore||-1==a.utils.arrayIndexOf(f.ignore,c)){var e=h[c],j=f,k=i||"";h instanceof Array?i&&(k+="["+c+"]"):(i&&(k+="."),k+=c),j.parentName=k;if(!(-1===a.utils.arrayIndexOf(f.copy,c)&&-1===a.utils.arrayIndexOf(f.include,c)&&h[p]&&h[p].mappedProperties&&!h[p].mappedProperties[c])||h instanceof Array)switch(b.getType(a.utils.unwrapObservable(e))){case"object":case"undefined":j=f.visitedObjects.get(e),g[c]="undefined"!==b.getType(j)?j:b.visitModel(e,d,f);break;default:g[c]=d(e,f.parentName)}}}),g}});